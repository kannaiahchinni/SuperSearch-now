<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_rest_message_fn">
    <sys_rest_message_fn action="INSERT_OR_UPDATE">
        <authentication_type>inherit_from_parent</authentication_type>
        <basic_auth_password/>
        <basic_auth_profile/>
        <basic_auth_user/>
        <content>{&#13;
  "data": [&#13;
    {&#13;
      "data": "(function executeRule(current, previous /*null when async*/) {\n\t\n var vendorRiskManagementService = new VendorRiskManagementService();\n vendorRiskManagementService.createAppSecTask(current);\n\t\n})(current, previous);",&#13;
      "result": ""&#13;
    },&#13;
    {&#13;
      "data": "var LeadAutomationUtil = Class.create();\nLeadAutomationUtil.prototype = {\n  _verbose: false,\n  _lock: false,\n  _audit: false,\n  _automationEnabled: false,\n  _tableName: 'u_adr_area_play_mapping',\n  _leadStatusALogic: ['Open', 'Attempting to Contact', 'Engaged', 'Reassigned'], // possibility to move into property file.\n  _leadStatusBLogic: ['Remarket', 'Qualified', 'List Import', 'Hold', 'Rejected'],\n  _leadDateRange: 90,\n  _leadDateEncodedQuery: '',\n  _guestUserSysId: '',\n  _logger: '',\n  _constants: {\n    OPEN: 'Open',\n    PLAY: 'u_play',\n    AREA: 'u_area',\n    ADR: 'u_adr',\n    COUNT: 'u_count',\n    COUNTRY: 'u_country',\n    STATE: 'u_state',\n    ACTIVE: 'u_active',\n    SYS_ID: 'sys_id',\n    US: 'us',\n    CA: 'ca',\n    VERBOSITY: 'adr.roundrobin.log.verbosity',\n    LOCK: 'adr.roundrobin.enable.lock',\n    AUDIT: 'adr.roubdrobin.enable.audit',\n    AUTOMATION_ENABLED: 'adr.automation.enabled',\n    DATE_RANGE: 'adr.lead.lastAssigned.date.range'\n  },\n  _log: function(info, required) {\n    if (this._verbose || required) {\n      gs.log(info, 'LeadAutomationUtil');\n    }\n  },\n  initialize: function() {\n    this._verbose = gs.getProperty(this._constants.VERBOSITY) === 'true'; // change this property with Eloqua logger property if needed\n    this._lock = gs.getProperty(this._constants.LOCK) === 'true';\n    this._audit = gs.getProperty(this._constants.AUDIT) === 'true';\n    this._automationEnabled = gs.getProperty(this._constants.AUTOMATION_ENABLED) === 'true';\n    this._leadDateRange = gs.getProperty(this._constants.DATE_RANGE);\n    this._leadDateEncodedQuery = 'u_adr_assigned_dateONLast ' + this._leadDateRange + ' days@javascript:gs.daysAgoStart(' + this._leadDateRange + ')@javascript:gs.daysAgoEnd(0)';\n    this._guestUserSysId = EloquaLeadManagementUtil.getGuestUser().sys_id;\n  },\n  getAdrRecord: function(play, area, leadSysId) {\n    this._log(\" Running get ADR record for leadSysId\");\n    var adrGr = new GlideRecord(this._tableName);\n    adrGr.addQuery(this._constants.PLAY, play);\n    adrGr.addQuery('u_area', area); //  getting sys_id\n    adrGr.orderBy(this._constants.COUNT);\n    adrGr.orderBy(this._constants.ADR);\n    adrGr.query();\n    if (adrGr.next()) {\n      return adrGr;\n    }\n    return;\n\n  },\n  getAdr: function(play, area, leadSysId) {\n    this._log(\" Runing ADR Logic for lead with sysId \" + leadSysId + \" with Area = \" + area + \" and Play =  \" + play, false);\n\n    var adrGr = this.getAdrRecord(play, area, leadSysId);\n\n    var sysId;\n    var adrSysId;\n\n    if (adrGr) {\n      sysId = adrGr.getValue(this._constants.SYS_ID);\n      /* if (this._lock) {\n      \tthis._log(\" adr sys_id before log with lead \" + leadSysId + \"and  adr sys_id \" + sysId);\n      \tadrLock = this._getLock(this._tableName, sysId);\n      }*/\n      adrSysId = adrGr.getValue(this._constants.ADR);\n      var count = adrGr.getValue(this._constants.COUNT);\n      this._log(\" Getting count for Lead  with sysId \" + leadSysId + \" and adrSysId \" + adrSysId + \"  with count (before update) \" + count, false);\n      count = parseInt(count) + 1;\n      adrGr.u_count = Math.floor(count);\n      adrGr.update();\n      this._log(\" Getting count for Lead  with sysId \" + leadSysId + \" and adrSysId \" + adrSysId + \"  with count (after update) \" + count, false);\n      /*if (this._lock) {\n      \tthis._releaseLock(sysId);\n      }*/\n      if (this._audit) {\n\n        this._auditLeadAndADR(play, area, adrSysId, leadSysId, 'ADR assigned to Lead by Automation');\n\n      }\n    }\n\n    return adrSysId;\n  },\n  _auditLeadAndADR: function(play, area, adr, leadSysId, comments) {\n    this._log(\"Inside of  audit function for  lead with sysId \" + leadSysId, false);\n    var auditGr = new GlideRecord('u_lead_automation_audit');\n    auditGr.initialize();\n    auditGr.u_area = area;\n    auditGr.u_play = play;\n    auditGr.u_adr = adr;\n    auditGr.u_lead = leadSysId;\n    auditGr.insert();\n  },\n  _getLock: function(table, sysId) {\n    this._log(\" Getting lock for table \" + table + \" with sys_id \" + sysId, false);\n    return new GlideRecordLock(table, sysId);\n  },\n  _releaseLock: function(sysId) {\n    this._log(\" releasing lock for table \" + this._tableName + \" sys_id \" + sysId, false);\n    adrLock.release();\n  },\n  _getLeadAssignedIn90Days: function(lead, account, play) {\n\n    this._log(\" Inside of 90 days logic to find the ADR which is assigned in 90days back with Play = \" + play + \" sys_id of lead = \" + lead.sys_id, false);\n    var leadGr = new GlideRecord('sales_lead');\n    leadGr.addQuery('account', account.sys_id);\n    leadGr.addQuery('assigned_to.ref_u_employee.u_gdc_play', play);\n    leadGr.addQuery('assigned_to.active', true);\n    leadGr.addQuery('assigned_to', 'NOT IN', this._guestUserSysId); // added filter to exclude Guest user from list.\n    leadGr.addEncodedQuery(this._leadDateEncodedQuery);\n    leadGr.orderByDesc('u_adr_assigned_date');\n    leadGr.query();\n\n    if (leadGr.next()) {\n      this._log(\" Got the ADR for 90 days logic \" + leadGr.assigned_to + \" with sys_id  \" + lead.sys_id, false);\n      return leadGr.assigned_to;\n    }\n    this._log(\" No ADR found with 90 days logic .. returning null \" + lead.sys_id, false);\n    return null;\n\n  },\n  _deriveAreaAndPlay: function(lead, account, ninetyDaysLogic) { // return adr sysId  or Lead object rather than true/false.\n    this._log('drive the area and play for lead ' + lead.sys_id, false);\n    var adrSysId;\n    try {\n      var areaObj = this._deriveStateAndCountry(lead, account);\n      var area = this._getArea(areaObj, lead.sys_id);\n      // If area is null .. no need to evaluate play and Round robin logic.\n      if (JSUtil.nil(area)) {\n        this._log(\" Area is null for lead \" + lead.sys_id + \" terminating automation logic\", false);\n        return adrSysId;\n      }\n      var play = this._deriveLeadPlay(lead);\n\n\n      var lock_name = 'adr_lock';\n      var adr_lock = new GlideMutex.get(lock_name);\n      while (adr_lock.toString() === undefined) {\n        this._log(\" Lead with sys_id \" + lead.sys_id + \" is waiting for lock \" + adr_lock.toString(), false);\n        // gs.sleep(1000);\n        adr_lock = new GlideMutex.get(lock_name); // trying to get lock for\n      }\n      this._log(\" got the lock for lead with sys_id \" + lead.sys_id, false);\n\n      // include 90 days logic\n      if (ninetyDaysLogic &amp;&amp; JSUtil.notNil(play)) {\n        this._log(\"Calling 90 days logic for lead with sys_id = \" + lead.sys_id, false);\n\n        adrSysId = this._getLeadAssignedIn90Days(lead, account, play);\n        if (JSUtil.notNil(adrSysId)) {\n          lead.assigned_to = adrSysId;\n          lead.u_lead_assigned_using = LeadConstants.LEAD_ASSIGNED_USING_SAME_ACCOUNT_PLAY;\n          lead.u_adr_assigned_date = gs.nowDateTime();\n          this._log(\" Updating Lead Assigned Using with \" + lead.u_lead_assigned_using + \" for lead with sys_id \" + lead.sys_id, false);\n\n\n        }\n      }\n\n      if (JSUtil.notNil(area) &amp;&amp; JSUtil.notNil(play) &amp;&amp; JSUtil.nil(adrSysId)) {\n        this._log(\" Calling getAdr to get ADR with following area = \" + area + \" and play = \" + play + \" with lead sys_id \" + lead.sys_id, false);\n\n        adrSysId = this.getAdr(play, area, lead.sys_id);\n        if (JSUtil.notNil(adrSysId)) {\n          this._log(\" Got adr ADR Sys_id = \" + adrSysId + \" for lead with sys_id \" + lead.sys_id, false);\n          lead.assigned_to = adrSysId;\n          lead.u_lead_assigned_using = LeadConstants.LEAD_ASSIGNED_USING_PLAY_RULES;\n          lead.u_adr_assigned_date = gs.nowDateTime();\n          this._log(\" Updating Lead Assigned Using with \" + lead.u_lead_assigned_using + \" for lead with sys_id \" + lead.sys_id, false);\n\n          //lead.setWorkflow(false);--&gt; Enabling this improves performance.\n         lead.update(); // updating lead\n\n        } else {\n          this._log(\"No ADR found for Area \" + area + \"  and Play \" + play + \" for Lead with sys_id  \" + lead.sys_id, false);\n        }\n      }\n      if (adr_lock.toString() != undefined) {\n        this._log(\" releasing the adr lock \");\n        adr_lock.release(); // releasing glide mutex log afte lead update ....\n      }\n\n    } catch (error) {\n      this._log(\"Error occured in Derive and Play for Lead \" + lead.sys_id + \" \" + error.message, true);\n      if (adr_lock.toString() != undefined) {\n        adr_lock.release();\n      }\n    }\n\n    return adrSysId;\n  },\n  _deriveStateAndCountry: function(lead, account) {\n\n    var areaObj = {};\n    if (JSUtil.notNil(lead) &amp;&amp; JSUtil.notNil(account)) {\n      this._log(\" Both lead and account are not null \" + lead.sys_id, false);\n      if (JSUtil.nil(lead.country) &amp;&amp; JSUtil.nil(account.country)) {\n        this._log(\"Both Lead and Account country is blank.. returning empty Area object \" + lead.sys_id, false);\n        return areaObj;\n      }\n      if (JSUtil.notNil(account.country) &amp;&amp; (account.country.toLowerCase() == this._constants.US || account.country.toLowerCase() == this._constants.CA) &amp;&amp; JSUtil.notNil(lead.country) &amp;&amp; (lead.country.toLowerCase() == this._constants.US || lead.country.toLowerCase() == this._constants.CA)) {\n        this._log(\" Both Account and Lead country falls into US/CA .. Preparing area object with Account state and country \" + lead.sys_id, false);\n        areaObj = this._prepareAreaObj(account);\n      } else if (JSUtil.notNil(account.country) &amp;&amp; JSUtil.notNil(lead.country)) {\n        if (lead.country == account.country) {\n          this._log(\" Both Account and Lead country are same  .. Preparing area object with Account state and country \" + lead.sys_id, false);\n          areaObj = this._prepareAreaObj(account);\n        } else {\n          this._log(\" Both Account and Lead country are different  .. Preparing area object with Lead state and country \" + lead.sys_id, false);\n          areaObj = this._prepareAreaObj(lead);\n        }\n      } else if (JSUtil.nil(account.country) &amp;&amp; JSUtil.notNil(lead.country)) {\n        this._log(\"  Account is empty and Lead is not null  .. Preparing area object with Lead state and country \" + lead.sys_id, false);\n        areaObj = this._prepareAreaObj(lead);\n      }\n    } else if (JSUtil.notNil(lead) &amp;&amp; JSUtil.nil(account)) {\n      this._log(\"  Account is empty and Lead is not null  .. Preparing area object with Lead state and country \" + lead.sys_id, false);\n      areaObj = this._prepareAreaObj(lead);\n    }\n    this._log(\"area object is  \" + JSON.stringify(areaObj) + lead.sys_id, false);\n\n\n    return areaObj;\n  },\n  _prepareAreaObj: function(obj) {\n    var area = {};\n    if (JSUtil.notNil(obj.state)) {\n      area.state = obj.state + '';\n    }\n    area.country = obj.country + '';\n    return area;\n  },\n  /*\n\t\t\tTo dervie Area from u_lead_assignment_country using country and state.\n\t\t\tinputObj having following properties  ( state &amp; country ).\n \t\t\t*/\n  _getArea: function(inputObj, leadSysId) {\n\n    if (JSUtil.nil(inputObj.country) &amp;&amp; JSUtil.nil(inputObj.state)) {\n      this._log(\"Both Country and State value are empty .. No Area found\" + leadSysId, false);\n      return null;\n    }\n    var mappingGr = new GlideRecord('u_lead_assignment_country');\n    if (JSUtil.notNil(inputObj.country)) {\n      mappingGr.addQuery(this._constants.COUNTRY, inputObj.country);\n    }\n    if (JSUtil.notNil(inputObj.state)) {\n      mappingGr.addQuery(this._constants.STATE, inputObj.state);\n    } else {\n      mappingGr.addNullQuery(this._constants.STATE); // added state blank condition if state is empty..\n    }\n    mappingGr.addQuery(this._constants.ACTIVE, true);\n    mappingGr.addNotNullQuery(this._constants.AREA);\n    mappingGr.query();\n    if (mappingGr.getRowCount() == 1 &amp;&amp; mappingGr.next()) {\n      var area = mappingGr.getValue(this._constants.AREA);\n      this._log(\" Got area for Lead with sysId = \" + leadSysId + \"  Area = \" + mappingGr.u_area.u_name, false);\n\n      return area;\n    } else {\n      this._log(\" Got more than one area/No Area found . Considering area is empty for this lead \" + leadSysId, false);\n      return null;\n    }\n\n  },\n  _deriveLeadPlay: function(lead) {\n\n\n    var match = false;\n    var rulePassed = null;\n    try {\n      this._log(' Play derivation logic is running for lead with sys_id ' + lead.sys_id, false);\n      var rule = new GlideRecord(\"u_gdc_play_rule\");\n      rule.addQuery('u_active', true);\n      rule.orderBy(\"order\");\n      rule.query();\n      while (rule.next()) {\n        var filter = Packages.com.glide.script.Filter;\n        // check to see if condition matches\n        //this._log(' Rule Condition ' + rule.u_conditions + \" for lead with sys_id \" + lead.sys_id, false);\n        match = filter.checkRecord(lead, rule.u_conditions);\n\n        if (match &amp;&amp; (JSUtil.notNil(rule.u_play))) {\n          rulePassed = true;\n          this._log(\" Matched Play Rule name \" + rule.name + \" for lead  with sys_id \" + lead.sys_id + \" and Play Rule condition is = \" + rule.u_conditions, false);\n\n          this._log(\" Play found for lead  with sys_id \" + lead.sys_id + \" Play is = \" + rule.u_play.u_name, false);\n\n\n          return rule.u_play;\n        }\n      }\n      if (!rulePassed) {\n        this._log(\" No play rule found for lead with Sys_id \" + lead.sys_id, false);\n        return null;\n      }\n    } catch (ex) {\n      this._log('Exception occured while deriving play for lead with sys_id' + lead.sys_id + ex.message, true);\n      return null;\n    }\n\n\n  },\n  _checkAssignedToAndPlay: function(lead) {\n    if (JSUtil.notNil(lead.assigned_to) &amp;&amp; lead.assigned_to.active) {\n      if (JSUtil.notNil(lead.assigned_to.u_gdc_play) &amp;&amp; lead.assigned_to.u_gdc_play.u_valid_gdc_play &amp;&amp; lead.assigned_to.u_gdc_play.u_active) {\n        this._log('Assinged_to with valid and active gdc play. Dont run deriveLeadPlay for lead ' + lead.sys_id, false);\n        return false;\n      } else {\n        this._log('Assinged_to is not null or assigned to  does not have valid gdc_play or active gdc play. Running deriveLeadPlay for lead ' + lead.sys_id, false);\n        return true;\n      }\n    } else {\n      this._log('Assinged_to is null or assigned to is not active. Running deriveLeadPlay for lead ' + lead.sys_id, false);\n      return true;\n    }\n  },\n  /*\n\t\t\tAutomation logic will start from here..\n\t\t\t1. Lead object\n\t\t\t2. Account object\n\t\t\t3. oldLeadStatus will come after some rules.. it won't come from eloqua ..\n \t\t\t*/\n  checkExistingLead: function(lead, account, oldLeadStatus,eloquaAssignedTo) {\n\n    this._log(\"Executing Lead Automation for existing lead with sys_id = \" + lead.sys_id + \" with lead number \" + lead.number, false);\n    this._log(\"Existing lead with following status = \" + lead.lead_status + \" oldLeadStatus \" + oldLeadStatus);\n    var assinged_to;\n\n    if (this._automationEnabled) {\n      this._log(\"Existing lead with following status = \" + lead.lead_status + \" oldLeadStatus \" + oldLeadStatus);\n      var newLeadStatus = lead.lead_status + '';\n      try {\n        if (JSUtil.notNil(lead)) {\n\n          if (this._leadStatusALogic.indexOf(oldLeadStatus.toString()) &gt; -1 &amp;&amp; newLeadStatus === this._constants.OPEN) {\n            this._log(\"Running logic A for lead \" + lead.sys_id, false);\n\n            if (this._checkAssignedToAndPlay(lead)) {\n              this._log(\"logic A :Lead not having Assigned to with Valid GDC play and GDC Area..  \" + lead.sys_id, false);\n\t\t\t  //STRY0785655 If ELOQUA assigned to is present, then assign lead to ELOQUA assigned to.\n\t\t\t  if(JSUtil.notNil(eloquaAssignedTo) &amp;&amp; EloquaLeadMappingUtil.isServiceNowUser(eloquaAssignedTo)){\n\t\t\t\t  this._log(\"logic A :eloquaAssignedTo is present and valid employee . Assigning it to lead  \" + lead.sys_id, false);\n\t\t\t\t  var user = EloquaLeadMappingUtil.isServiceNowUser(eloquaAssignedTo);\n\t\t\t\t  assinged_to = user.sys_id;\n\t\t\t\t  lead.u_lead_assigned_using = LeadConstants.LEAD_ASSIGNED_USING_ELOQUA;\n\t\t\t\t}else{\n\t\t\t\t  assinged_to = this.checkNewLead(lead, account);\n\t\t\t  }\n              //assinged_to = this._deriveAreaAndPlay(lead, account, false);\n            } else {\n              this._log(\"logic A :Lead having Assigned to with Valid GDC play and GDC Area .. will assign the lead to same assigned to\" + lead.sys_id, false);\n              assinged_to = lead.assigned_to;\n            }\n\n          } else if (this._leadStatusBLogic.indexOf(oldLeadStatus.toString()) &gt; -1 &amp;&amp; newLeadStatus === this._constants.OPEN) {\n            this._log(\"Running logic B for lead \" + lead.sys_id, false);\n\t\t\t  if(JSUtil.notNil(eloquaAssignedTo) &amp;&amp; EloquaLeadMappingUtil.isServiceNowUser(eloquaAssignedTo)){\n\t\t\t\t  this._log(\"logic B :eloquaAssignedTo is present and valid employee . Assigning it to lead  \" + lead.sys_id, false);\n\t\t\t\t  var userB = EloquaLeadMappingUtil.isServiceNowUser(eloquaAssignedTo);\n\t\t\t\t  assinged_to = userB.sys_id;\n\t\t\t\t  lead.u_lead_assigned_using = LeadConstants.LEAD_ASSIGNED_USING_ELOQUA;\n\t\t\t\t}else{\n\n             assinged_to = this.checkNewLead(lead, account);\n            //assinged_to = this._deriveAreaAndPlay(lead, account, false);\n\t\t\t\t}\n          }\n        } else {\n          this._log('Lead Assignment Automation will not run for null lead object ' + lead.sys_id, false);\n          assinged_to = null;\n        }\n      } catch (error) {\n        this._log(\"Error occured while procesisng Lead automation logic  \" + error.message + \" for lead with sys_id \" + lead.sys_id, true);\n        assinged_to = null;\n      }\n    } else {\n      this._log(\"Skipping Lead automation logic.. Automation flag is not enabled [adr.automation.enabled] \" + lead.sys_id, false);\n      assinged_to = null;\n    }\n\n    return assinged_to;\n  },\n  checkNewLead: function(lead, account) {\n\n    var assinged_to;\n    try {\n      this._log(\" Running Lead Assignment Automation for lead with sys_id \" + lead.sys_id + \"  and lead number = \" + lead.number, false);\n      if (JSUtil.notNil(lead)) {\n        this._log(\"Lead is not null \" + lead.sys_id);\n\n        if (JSUtil.notNil(account) &amp;&amp; JSUtil.notNil(account.inside_sales_rep) &amp;&amp; account.inside_sales_rep.active) {\n          this._log(\" Account is not null and sales rep is existed and active.\" + lead.sys_id, false);\n\t\t\tthis._log(\"account is not null \" + account.sys_id +' : isAccountInSameCountryOrPartnerAndMSP' +MKTUtil.isAccountInSameCountryOrPartnerAndMSP(account,lead)+ '   '+lead.sys_id);\n\n\t\t\tvar isAccountInSameCountryOrPartnerAndMSP = MKTUtil.isAccountInSameCountryOrPartnerAndMSP(account,lead);\n\n\t\t\tif(isAccountInSameCountryOrPartnerAndMSP) {\n\n\t\t  this._log(\"isAccountInSameCountryOrPartnerAndMSP \" + isAccountInSameCountryOrPartnerAndMSP + lead.sys_id);\n          this._log(\" Account is not null and sales rep is existed and active and account/lead are in same county or Account is a partner or MSP.. No RoundRobin logic for lead  \" + lead.sys_id, false);\n\n          assinged_to = account.inside_sales_rep;\n          lead.u_lead_assigned_using = LeadConstants.LEAD_ASSIGNED_USING_ACCOUNT_ADR;\n          lead.u_adr_assigned_date = gs.nowDateTime();\n          this._log(\" Updating Lead Assigned Using with \" + lead.u_lead_assigned_using + \" for lead with sys_id \" + lead.sys_id, false);\n\n        }\n\t  }\n\t\telse {\n          this._log(\" checking account is not null condition  \" + lead.sys_id);\n          if (JSUtil.nil(account)) {\n            this._log(\" Account is null for new lead \" + lead.sys_id + \" No 90 days logic is false \", false);\n            assinged_to = this._deriveAreaAndPlay(lead, account, false);\n          } else if (JSUtil.nil(account.inside_sales_rep)) {\n            this._log(\" Account is not null and no inside sales rep account  \" + lead.sys_id + \" No 90 days logic will apply \", false);\n            assinged_to = this._deriveAreaAndPlay(lead, account, true); // Need to pass additional parameter to include 90 days logic\n          } else if (JSUtil.notNil(account.inside_sales_rep) &amp;&amp; !account.inside_sales_rep.active) {\n            this._log(\" Account  and inside sales rep are not null and sales rep is not active \" + lead.sys_id + \" 90 days logic will apply \", false);\n            assinged_to = this._deriveAreaAndPlay(lead, account, true);\n          }\n        }\n      } else {\n        this._log(\"Lead Assignment Automation will not run for null lead object\", false);\n        assinged_to = null;\n      }\n    } catch (ex) {\n      this._log(\" Exception occured while processing new Lead with Automation \" + ex, true);\n    }\n    return assinged_to;\n  },\n  type: 'LeadAutomationUtil'\n};\n",&#13;
      "result": ""&#13;
    }&#13;
  ]&#13;
}</content>
        <function_name>astParser</function_name>
        <http_method>post</http_method>
        <lock>false</lock>
        <oauth2_profile/>
        <protocol_name/>
        <qualified_name>AST Parser [ astParser ]</qualified_name>
        <rest_endpoint>http://10.165.208.41:3000/api/ast/tree/parse</rest_endpoint>
        <rest_message display_value="AST Parser">d8148cd8db9a6f84b1a6f5361d961930</rest_message>
        <sys_class_name>sys_rest_message_fn</sys_class_name>
        <sys_created_by>karunakar.medamoni</sys_created_by>
        <sys_created_on>2018-12-06 09:54:36</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>f14480d0db9a6f84b1a6f5361d961987</sys_id>
        <sys_mod_count>9</sys_mod_count>
        <sys_name>astParser</sys_name>
        <sys_package display_value="super search" source="x_snc_super_search">4863b5fddbc52740ba189ea3db961925</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="super search">4863b5fddbc52740ba189ea3db961925</sys_scope>
        <sys_update_name>sys_rest_message_fn_f14480d0db9a6f84b1a6f5361d961987</sys_update_name>
        <sys_updated_by>karunakar.medamoni</sys_updated_by>
        <sys_updated_on>2018-12-06 10:23:20</sys_updated_on>
        <use_basic_auth>false</use_basic_auth>
        <use_mid_server display_value="SJC4_OI_TEST_POC">5416128adb6e5380314dff971d9619cc</use_mid_server>
        <use_mutual_auth>false</use_mutual_auth>
    </sys_rest_message_fn>
</record_update>
